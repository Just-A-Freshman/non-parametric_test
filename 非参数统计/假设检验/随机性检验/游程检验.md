# 游程检验
## 1. 概述
### 1.1 作用
游程检验主要用于检验二元随机序列的随机性。在统计学中，当我们通过**简单随机抽样**获取样本数据时，可以使用游程检验来验证抽样过程是否足够随机。

### 1.2 统计量
游程检验的核心统计量是"**游程数**"。所谓游程，指的是数据中连续相同元素的"串"。例如，对于二元序列：$\{0, 0, 1, 1, 1, 0, 1\}$，可以划分为4个游程：
- $\{0, 0\}$（长度2）
- $\{1, 1, 1\}$（长度3）  
- $\{0\}$（长度1）
- $\{1\}$（长度1）

游程检验的统计量我们记作$R$，$x_i$表示第$i$个样本点，$n$表示样本量。用数学表达式表达游程数需要借助示性函数。定义示性函数：
$$
I_i = 
\left\{
\begin{array}{l}
0, \quad x_i = x_{i+1}\\
1, \quad x_i \neq x_{i+1}
\end{array}
\right.
$$

所以，$I_i$就记录了"转折"的个数。只需初始化一个游程数就得到了：
$$
R = 1 + \sum_{i=1}^{n-1} I_i
$$

### 1.3 拒绝域
游程数的极端值反映了序列的非随机性：

1. **成群效应**：当$R$过小时，表明数据过度聚集
   - 例：$\{0, 0, 0, 0, 1, 1, 1, 1\}$，$R=2$

2. **混合效应**：当$R$过大时，表明数据过度交替
   - 例：$\{1, 0, 1, 0, 1, 0, 1, 0\}$，$R=8$

3. **随机序列**：游程数适中时，认为序列随机

因此，拒绝域为：
- 双侧检验：$R < R_{\text{lb}}$ 或 $R > R_{\text{ub}}$
- 单侧检验（如检测成群效应）：$R < R_{\text{lb}}$

## 2. 概率分布列
### 2.1. 样本空间大小
设二元序列包含$n_0$个0和$n_1$个1，$n = n_0 + n_1$。将所有元素随机排列到$n$个位置，总排列数为：
$$
\binom{n}{n_0} = \binom{n}{n_1}
$$

### 2.2 游程数的组合结构
游程数的构成有多种视角。观察上面的例子：$\{0, 0, 1, 1, 1, 0, 1\}$，这无非是两串0和两串1组成的。只要我们能把3个0拆分两份，4个1也拆分两份，最后交替排列，不就得到了游程数为4的序列？因此，我们有以下步骤：

1. **确定0游程和1游程的个数**
因为0游程和1游程是交替排序的，两者游程数的差距显然不会大于1。
- 当$R = 2K$时，必然有$K$个0游程和$K$个1游程；
- 当$R = 2K + 1$时，必然是一方$K$个游程，另一方$(K+1)$个游程

2. **数字拆分**
- 对于数字0来说，如果想把它拆成$K$份，我们可以往数字0中$(n_0 - 1)$个间隙随机插入\((K - 1)\)根棍，共$\binom{n_0 - 1}{K - 1}$种组合。
- 对于数字1，假设想拆分成$(K + 1)$份，同理可得有$\binom{n_1 - 1}{K}$种组合。

3. **交替排列**
- 如果我们有了3串"1"和2串"0"后，要组成5个游程(奇数)，1游程必须放在开头(10101)，因此只有一种排法；
- 如果我们有2串"1"和2串"0"，要组成4个游程(偶数)，既可以是"0"游程开头，也可以是"1"游程开头(0101或1010)，因此就有两种排法。

于是，我们得到了：
- 当游程数为偶数时：
$$
\#(R = 2K) = 2\binom{n_0 - 1}{K - 1} \binom{n_1 - 1}{K - 1}
$$
- 当游程数为奇数时：
$$
\#(R = 2k + 1) = \binom{n_0 - 1}{k} \binom{n_1 - 1}{k - 1} + \binom{n_0 - 1}{k - 1} \binom{n_1 - 1}{k}
$$

### 2.3.结论
注意$R$的取值范围：$2 \leq R \leq 2\min(n_0, n_1) + I(n_0 \neq n_1)$，其中，当$n_0 \neq n_1$时$I(n_0 \neq n_1) = 1$。
- 当$R$为偶数：
$$P(R = 2k) = \frac{2\binom{n_0 - 1}{k - 1}\binom{n_1 - 1}{k - 1}}{\binom{n}{n_0}}
$$
- 当$R$为奇数：
$$
P(R = 2k + 1) = \frac{\binom{n_0 - 1}{k} \binom{n_1 - 1}{k - 1} + \binom{n_0 - 1}{k - 1} \binom{n_1 - 1}{k}}{\binom{n}{n_0}}
$$


## 3. 近似分布
### 3.1.期望
$$
E(R) = E(1 + \sum_{i=1}^{n-1} I_i) = 1 + \sum_{i=1}^{n-1} E(I_i)
$$计算\(E(I_i)\):
$$
\begin{aligned}
E(I_i) &= 0 * P(I_i = 0) + 1 * P(I_i = 1) \\
&= P(I_i = 1)
\\ &= \frac{n_0}{n} \cdot \frac{n_1}{n-1} + \frac{n_1}{n} \cdot \frac{n_0}{n-1} \\ &= \frac{2n_0 n_1}{n(n-1)}
\end{aligned}$$从而:
$$
E(R) = 1 + (n-1)\cdot \frac{2n_0 n_1}{n(n-1)} = 1 + \frac{2n_0 n_1}{n}
$$

### 3.2. 方差
#### 3.2.1 示性函数.方差项
$$
\begin{aligned}
Var(R) &= Var(1 + \sum_{i=1}^{n-1} I_i) \\ 
&= Var(\sum_{i=1}^{n-1} I_i) \\
&=\sum_{i=1}^{n-1}Var(I_i) + 2\sum_{i \neq j}  Cov(I_i, I_j)
\end{aligned}
$$

其中，因为$I_i \sim B(1, p)$，其中，$p = \frac{2n_0n_1}{n(n-1)}$。因此：
$$Var(I_i) = p(1 - p)$$

#### 3.2.2 示性函数.协方差项

$$Cov(I_i, I_j) = E[I_iI_j]-E[I_i]E[I_j]$$容易求得$E(I_i)E(I_j) = p^2$，难点在于$E(I_iI_j)$，需要分情况讨论。

##### 情况1：非相邻（$|j - i| \geq 2$）
此时$I_i$依赖于$(x_i, x_{i+1})$，$I_j$依赖于$(x_j, x_{j+1})$，且两组变量无重叠。

- 如果是无限总体，$I_i = 0$或$I_i = 1$都不影响后面剩余0或1的个数，$I_i$和$I_j$完全独立；
- 但随机游程检验的序列是有限的，$I_i = 0$或$I_i = 1$会影响后面剩余0或1的个数，进而影响$I_j$(**间接影响**)。但是，当$n$足够大时，我们可以近似认为$I_i$与$I_j$之间独立。

因此，$E(I_iI_j) \approx E(I_i)E(I_j) \implies Cov(I_i, I_j) \approx 0$

##### 情况2：相邻（$j = i+1$）
此时$I_i$依赖于$(x_i, x_{i+1})$，$I_j=I_{i+1}$依赖于$(x_{i+1}, x_{i+2})$，共享变量$x_{i+1}$，可以直接计算这部分关联性。有：
$$
\begin{aligned}
E(I_iI_j) &= 0 * P(I_iI_j = 0) + 1 * P(I_iI_j = 1) \\ &= P(I_i = 1 \text{且} I_j = 1)
\end{aligned}
$$
|   样本   | 值-1  | 概率-1    |值-2   | 概率-2    |
| ---------| -----|-----------|-----|------------|
|     $X_i$|   1  | $\frac{n_1}{n}$  | 0| $\frac{n_0}{n}$ |
| $X_{i+1}$|   0  | $\frac{n_0}{n-1}$| 1| $\frac{n_1}{n-1}$|
| $X_{i+2}$|   1  | $\frac{n_1 - 1}{n-2}$| 0| $\frac{n_0 - 1}{n-2}$|

由上表可得： 
$$
\begin{align*}
E[I_i I_{i+1}] &= \frac{n_1 n_0 (n_1 - 1) + n_0 n_1 (n_0 - 1)}{n(n-1)(n-2)} \\
&= \frac{n_0 n_1}{n(n-1)}
\end{align*}
$$

注意到$\frac{n_0n_1}{n(n-1)} = \frac{1}{2}p$，因此：  
$$
Cov(I_i, I_{i+1}) = E[I_i I_{i+1}] - E[I_i]E[I_{i+1}] = \frac{1}{2}p - p^2
$$

### 3.2.3 结论
比较遗憾的是，尽管一波操作猛如虎，我们最终推导的方差还是和标准的结论不同(即便真的考虑非相邻协方差的影响)。下面给出的是标准结论：
$$
\operatorname{Var}(R) = \frac{2n_0n_1(2n_0n_1 - n)}{n^2(n-1)}
$$



## 4. R代码实现
```r
runTest <- function(
    x,
    alternative = c("less", "greater", "two.sided"),
    alpha = 0.05,
    exact = FALSE
) {
  alternative <- match.arg(alternative)
  
  # 计算基本参数
  n0 <- sum(x == 0)
  n1 <- sum(x == 1)
  n <- n0 + n1
  
  # 计算均值和方差
  mu_r <- 1 + 2 * n0 * n1 / n
  var_r <- (2 * n0 * n1 * (2 * n0 * n1 - n)) / (n^2 * (n - 1))
  
  # 计算游程数
  runs <- length(rle(x)$lengths)
  
  if (exact) {
    max_runs <-  2 * min(n0, n1) + (n0 != n1)
    prob <- rep(0, max_runs)
    for (r in 2:max_runs) {
      k <- r %/% 2
      if (r %% 2 == 0) {
        prob[r] <- 2 * choose(n0 - 1, k - 1) * choose(n1 - 1, k - 1) / choose(n0 + n1, n0)
      } else {
        term1 <- choose(n0 - 1, k - 1) * choose(n1 - 1, k)
        term2 <- choose(n0 - 1, k) * choose(n1 - 1, k - 1)
        prob[r] <- (term1 + term2) / choose(n0 + n1, n0)
      }
    }
    lower_tail <-  sum(prob[2:runs])
    upper_tail <-  sum(prob[runs:max_runs])
    if (alternative == "less") {p_value <- lower_tail}
    else if (alternative == "greater") {p_value <- upper_tail}
    else {p_value <- 2 * min(lower_tail, upper_tail)}
  }
  else{
    z <- (runs - mu_r) / sqrt(var_r)
    if (alternative == "less") {p_value <- pnorm(z)}
    else if (alternative == "greater") {p_value <- 1 - pnorm(z)}
    else {p_value <- 2 * min(pnorm(z), 1 - pnorm(z))}
  }
  
  # 返回结果
  list(
    `p-value` = p_value,
    `游程数` = runs,
    `样本数` = sprintf("n0 = %d, n1 = %d, n = %d", n0, n1, n),
    `均值` = mu_r,
    `方差` = var_r
  )
}


data <- c(1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0)
runTest(data, "two.sided", exact = T)
```

## 5. 局限性
仔细想想，游程数作为统计量其实并不足够合理。例如，下面的情况中，$X$和$Y$的游程数均为10。但我们肯定更倾向于认为$Y$是非随机的：
```
X = c(0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1)
Y = c(0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1)
```

这种情况可以说是"混合效应"和"成群效应"的叠加。当某个局部有强烈的成群效应，另外一个局部又有强烈的混合效应，序列本身是非随机的。但在游程检验下，这两种情况中和得到了非常"适中"的游程数，从而完美地通过了游程检验。
